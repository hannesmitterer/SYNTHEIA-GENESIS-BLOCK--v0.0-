<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYNTHEIA GENESIS BLOCK - Interactive Architecture</title>
    
    <!-- Self-contained visualization - no external dependencies -->
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            min-height: 100vh;
        }
        
        .header {
            text-align: center;
            padding: 2rem 0;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 2px solid #00ff88;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .header p {
            font-size: 1.1rem;
            color: #b0b0b0;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .graph-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            margin-bottom: 2rem;
            overflow: hidden;
        }
        
        .graph-header {
            background: rgba(0, 255, 136, 0.1);
            padding: 1rem;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
        }
        
        .graph-header h2 {
            color: #00ff88;
            margin-bottom: 0.5rem;
        }
        
        .graph-header p {
            color: #b0b0b0;
            font-size: 0.9rem;
        }
        
        #networkContainer {
            width: 100%;
            height: 600px;
            background: rgba(0, 0, 0, 0.2);
            position: relative;
            border-radius: 8px;
            overflow: hidden;
        }
        
        #graph-canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #graph-canvas:active {
            cursor: grabbing;
        }
        
        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 2rem;
        }
        
        .legend-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }
        
        .legend-item h3 {
            color: #00ff88;
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }
        
        .legend-item p {
            color: #b0b0b0;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        .controls {
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .control-group {
            display: inline-block;
            margin-right: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .control-group label {
            color: #00ff88;
            margin-right: 0.5rem;
            font-size: 0.9rem;
        }
        
        .control-group button {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #fff;
            padding: 0.3rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }
        
        .control-group button:hover {
            background: rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.4);
        }
        
        .node-info {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 1rem;
            display: none;
        }
        
        .node-info h4 {
            color: #00ff88;
            margin-bottom: 0.5rem;
        }
        
        .node-info p {
            color: #b0b0b0;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8rem;
            }
            
            .container {
                padding: 1rem;
            }
            
            #networkContainer {
                height: 400px;
            }
            
            .node-info {
                position: relative;
                width: 100%;
                margin-top: 1rem;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>SYNTHEIA GENESIS BLOCK</h1>
        <p>Interactive Project Architecture & Development Workflow</p>
    </header>
    
    <div class="container">
        <div class="graph-container">
            <div class="graph-header">
                <h2>Project System Architecture</h2>
                <p>Explore the interactive visualization below. Click and drag nodes, hover for details, and use the controls to customize the view.</p>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>Layout:</label>
                    <button onclick="updateLayout('hierarchicalLR')">Hierarchical</button>
                    <button onclick="updateLayout('force')">Force-Directed</button>
                    <button onclick="updateLayout('circle')">Circular</button>
                </div>
                <div class="control-group">
                    <label>View:</label>
                    <button onclick="network.fit()">Fit to Screen</button>
                    <button onclick="togglePhysics()">Toggle Physics</button>
                </div>
            </div>
            
            <div id="networkContainer">
                <canvas id="graph-canvas"></canvas>
            </div>
            <div class="node-info" id="nodeInfo">
                <h4 id="nodeTitle">Node Information</h4>
                <p id="nodeDescription">Select a node to see details</p>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <h3>üîß Core Components</h3>
                <p>Essential project files including source code, configuration, and documentation that form the foundation of the SYNTHEIA kernel.</p>
            </div>
            <div class="legend-item">
                <h3>üöÄ Build Pipeline</h3>
                <p>Automated CI/CD workflow that compiles the kernel, runs tests, and creates deployment artifacts using GitHub Actions.</p>
            </div>
            <div class="legend-item">
                <h3>üì¶ Deployment</h3>
                <p>Release management and distribution system that packages and distributes the built kernel through GitHub Pages and releases.</p>
            </div>
            <div class="legend-item">
                <h3>üåê Web Interface</h3>
                <p>Interactive web visualization and documentation interface that provides insights into the project architecture and development process.</p>
            </div>
        </div>
    </div>
    
    <script>
        // Self-contained graph visualization using Canvas
        class GraphVisualization {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = 1200;
                this.height = 600;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                
                // Graph data
                this.nodes = [
                    {id: 'main.c', label: 'main.c', x: 100, y: 300, vx: 0, vy: 0, group: 'core', color: '#ff6b6b', description: 'Main kernel source code - Entry point and core functionality'},
                    {id: 'readme', label: 'README.md', x: 200, y: 200, vx: 0, vy: 0, group: 'core', color: '#4ecdc4', description: 'Project documentation and setup instructions'},
                    {id: 'license', label: 'LICENSE', x: 200, y: 400, vx: 0, vy: 0, group: 'core', color: '#45b7d1', description: 'GPL-3.0 license file'},
                    
                    {id: 'actions', label: 'GitHub Actions', x: 400, y: 150, vx: 0, vy: 0, group: 'build', color: '#96ceb4', description: 'CI/CD pipeline for automated builds'},
                    {id: 'gcc', label: 'GCC Compiler', x: 500, y: 300, vx: 0, vy: 0, group: 'build', color: '#feca57', description: 'GNU Compiler Collection for kernel compilation'},
                    {id: 'artifacts', label: 'Build Artifacts', x: 600, y: 250, vx: 0, vy: 0, group: 'build', color: '#ff9ff3', description: 'Compiled kernel binary and packages'},
                    
                    {id: 'releases', label: 'GitHub Releases', x: 800, y: 200, vx: 0, vy: 0, group: 'deploy', color: '#a29bfe', description: 'Versioned releases with downloadable artifacts'},
                    {id: 'pages', label: 'GitHub Pages', x: 800, y: 350, vx: 0, vy: 0, group: 'deploy', color: '#fd79a8', description: 'Static site hosting for project visualization'},
                    
                    {id: 'git', label: 'Git Repository', x: 300, y: 100, vx: 0, vy: 0, group: 'workflow', color: '#fdcb6e', description: 'Version control and source management'},
                    {id: 'dev', label: 'Development', x: 150, y: 150, vx: 0, vy: 0, group: 'workflow', color: '#74b9ff', description: 'Local development and testing environment'},
                    
                    {id: 'html', label: 'index.html', x: 650, y: 400, vx: 0, vy: 0, group: 'web', color: '#00b894', description: 'Interactive web visualization interface'},
                    {id: 'viz', label: 'Graph Visualization', x: 750, y: 450, vx: 0, vy: 0, group: 'web', color: '#e17055', description: 'Dynamic network diagram of project architecture'},
                    
                    {id: 'memory', label: 'Memory Manager', x: 100, y: 450, vx: 0, vy: 0, group: 'future', color: '#636e72', description: 'Future: Kernel memory management system'},
                    {id: 'process', label: 'Process Manager', x: 150, y: 500, vx: 0, vy: 0, group: 'future', color: '#636e72', description: 'Future: Process scheduling and management'},
                    {id: 'drivers', label: 'Device Drivers', x: 200, y: 550, vx: 0, vy: 0, group: 'future', color: '#636e72', description: 'Future: Hardware abstraction layer'}
                ];
                
                this.links = [
                    {source: 'main.c', target: 'actions', label: 'triggers'},
                    {source: 'actions', target: 'gcc', label: 'uses'},
                    {source: 'gcc', target: 'artifacts', label: 'produces'},
                    {source: 'artifacts', target: 'releases', label: 'creates'},
                    {source: 'html', target: 'pages', label: 'deploys to'},
                    {source: 'git', target: 'main.c', label: 'contains'},
                    {source: 'git', target: 'readme', label: 'contains'},
                    {source: 'git', target: 'license', label: 'contains'},
                    {source: 'git', target: 'html', label: 'contains'},
                    {source: 'dev', target: 'main.c', label: 'modifies'},
                    {source: 'dev', target: 'git', label: 'commits to'},
                    {source: 'html', target: 'viz', label: 'implements'},
                    {source: 'viz', target: 'main.c', label: 'visualizes'},
                    {source: 'viz', target: 'actions', label: 'visualizes'},
                    {source: 'main.c', target: 'memory', label: 'will extend'},
                    {source: 'main.c', target: 'process', label: 'will extend'},
                    {source: 'main.c', target: 'drivers', label: 'will extend'}
                ];
                
                this.selectedNode = null;
                this.dragNode = null;
                this.isDragging = false;
                this.mousePos = {x: 0, y: 0};
                this.animationId = null;
                this.physicsEnabled = true;
                this.currentLayout = 'force';
                
                this.setupEventListeners();
                this.startAnimation();
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('click', this.handleClick.bind(this));
                
                window.addEventListener('resize', this.handleResize.bind(this));
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const node = this.getNodeAtPosition(x, y);
                if (node) {
                    this.dragNode = node;
                    this.isDragging = true;
                }
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                this.mousePos = {x, y};
                
                if (this.isDragging && this.dragNode) {
                    this.dragNode.x = x;
                    this.dragNode.y = y;
                    this.dragNode.vx = 0;
                    this.dragNode.vy = 0;
                } else {
                    // Check for hover
                    const hoveredNode = this.getNodeAtPosition(x, y);
                    this.canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
                }
            }
            
            handleMouseUp() {
                this.dragNode = null;
                this.isDragging = false;
            }
            
            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const node = this.getNodeAtPosition(x, y);
                if (node) {
                    this.selectedNode = node;
                    this.showNodeInfo(node);
                } else {
                    this.selectedNode = null;
                    this.hideNodeInfo();
                }
            }
            
            handleResize() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.width = rect.width;
                this.height = rect.height;
            }
            
            getNodeAtPosition(x, y) {
                for (const node of this.nodes) {
                    const radius = node.group === 'future' ? 15 : 20;
                    const dist = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
                    if (dist <= radius + 10) {
                        return node;
                    }
                }
                return null;
            }
            
            updatePhysics() {
                if (!this.physicsEnabled) return;
                
                const alpha = 0.1;
                const repulsion = 1000;
                const attraction = 0.1;
                const damping = 0.9;
                
                // Apply forces between nodes
                for (let i = 0; i < this.nodes.length; i++) {
                    const nodeA = this.nodes[i];
                    if (nodeA === this.dragNode) continue;
                    
                    // Repulsion from other nodes
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const nodeB = this.nodes[j];
                        if (nodeB === this.dragNode) continue;
                        
                        const dx = nodeA.x - nodeB.x;
                        const dy = nodeA.y - nodeB.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = repulsion / (dist * dist);
                        
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        
                        nodeA.vx += fx * alpha;
                        nodeA.vy += fy * alpha;
                        nodeB.vx -= fx * alpha;
                        nodeB.vy -= fy * alpha;
                    }
                    
                    // Center attraction
                    const centerX = this.width / 2;
                    const centerY = this.height / 2;
                    nodeA.vx += (centerX - nodeA.x) * 0.001;
                    nodeA.vy += (centerY - nodeA.y) * 0.001;
                }
                
                // Apply link forces
                for (const link of this.links) {
                    const sourceNode = this.nodes.find(n => n.id === link.source);
                    const targetNode = this.nodes.find(n => n.id === link.target);
                    
                    if (sourceNode && targetNode && sourceNode !== this.dragNode && targetNode !== this.dragNode) {
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = (dist - 100) * attraction;
                        
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        
                        sourceNode.vx += fx * alpha;
                        sourceNode.vy += fy * alpha;
                        targetNode.vx -= fx * alpha;
                        targetNode.vy -= fy * alpha;
                    }
                }
                
                // Update positions and apply damping
                for (const node of this.nodes) {
                    if (node === this.dragNode) continue;
                    
                    node.vx *= damping;
                    node.vy *= damping;
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    // Boundary constraints
                    const radius = node.group === 'future' ? 15 : 20;
                    node.x = Math.max(radius, Math.min(this.width - radius, node.x));
                    node.y = Math.max(radius, Math.min(this.height - radius, node.y));
                }
            }
            
            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Draw links
                this.ctx.strokeStyle = '#00ff88';
                this.ctx.lineWidth = 2;
                this.ctx.font = '10px "Courier New", monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = '#ffffff';
                
                for (const link of this.links) {
                    const sourceNode = this.nodes.find(n => n.id === link.source);
                    const targetNode = this.nodes.find(n => n.id === link.target);
                    
                    if (sourceNode && targetNode) {
                        // Draw link
                        this.ctx.beginPath();
                        this.ctx.moveTo(sourceNode.x, sourceNode.y);
                        this.ctx.lineTo(targetNode.x, targetNode.y);
                        
                        if (sourceNode.group === 'future' || targetNode.group === 'future') {
                            this.ctx.setLineDash([5, 5]);
                            this.ctx.globalAlpha = 0.5;
                        } else {
                            this.ctx.setLineDash([]);
                            this.ctx.globalAlpha = 0.7;
                        }
                        this.ctx.stroke();
                        this.ctx.globalAlpha = 1.0;
                        
                        // Draw arrow
                        const angle = Math.atan2(targetNode.y - sourceNode.y, targetNode.x - sourceNode.x);
                        const arrowLength = 15;
                        const arrowWidth = 8;
                        const targetRadius = targetNode.group === 'future' ? 15 : 20;
                        
                        const arrowX = targetNode.x - Math.cos(angle) * targetRadius;
                        const arrowY = targetNode.y - Math.sin(angle) * targetRadius;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(arrowX, arrowY);
                        this.ctx.lineTo(
                            arrowX - arrowLength * Math.cos(angle - Math.PI / 6),
                            arrowY - arrowLength * Math.sin(angle - Math.PI / 6)
                        );
                        this.ctx.moveTo(arrowX, arrowY);
                        this.ctx.lineTo(
                            arrowX - arrowLength * Math.cos(angle + Math.PI / 6),
                            arrowY - arrowLength * Math.sin(angle + Math.PI / 6)
                        );
                        this.ctx.stroke();
                        
                        // Draw link label
                        const midX = (sourceNode.x + targetNode.x) / 2;
                        const midY = (sourceNode.y + targetNode.y) / 2;
                        
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        const labelWidth = this.ctx.measureText(link.label).width + 8;
                        this.ctx.fillRect(midX - labelWidth / 2, midY - 8, labelWidth, 16);
                        
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillText(link.label, midX, midY + 3);
                    }
                }
                
                // Draw nodes
                this.ctx.font = '12px "Courier New", monospace';
                for (const node of this.nodes) {
                    const radius = node.group === 'future' ? 15 : 20;
                    const isSelected = node === this.selectedNode;
                    const isHovered = this.getNodeAtPosition(this.mousePos.x, this.mousePos.y) === node;
                    
                    // Draw node circle
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, radius + (isSelected || isHovered ? 5 : 0), 0, 2 * Math.PI);
                    this.ctx.fillStyle = node.color;
                    this.ctx.globalAlpha = node.group === 'future' ? 0.6 : 1.0;
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1.0;
                    
                    // Draw node border
                    this.ctx.strokeStyle = isSelected ? '#fff' : '#000';
                    this.ctx.lineWidth = isSelected ? 3 : 2;
                    this.ctx.stroke();
                    
                    // Draw node label
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(node.label, node.x, node.y + radius + 15);
                }
                
                // Draw tooltip for hovered node
                const hoveredNode = this.getNodeAtPosition(this.mousePos.x, this.mousePos.y);
                if (hoveredNode && !this.isDragging) {
                    this.drawTooltip(hoveredNode);
                }
            }
            
            drawTooltip(node) {
                const padding = 10;
                const maxWidth = 300;
                const lineHeight = 16;
                
                this.ctx.font = '12px "Courier New", monospace';
                
                // Word wrap the description
                const words = node.description.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (const word of words) {
                    const testLine = currentLine + (currentLine ? ' ' : '') + word;
                    const testWidth = this.ctx.measureText(testLine).width;
                    if (testWidth > maxWidth - padding * 2) {
                        if (currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            lines.push(word);
                        }
                    } else {
                        currentLine = testLine;
                    }
                }
                if (currentLine) lines.push(currentLine);
                
                // Calculate tooltip dimensions
                const titleWidth = this.ctx.measureText(node.label).width;
                const maxLineWidth = Math.max(titleWidth, ...lines.map(line => this.ctx.measureText(line).width));
                const tooltipWidth = Math.min(maxWidth, maxLineWidth + padding * 2);
                const tooltipHeight = (lines.length + 2) * lineHeight + padding * 2;
                
                // Position tooltip
                let tooltipX = this.mousePos.x + 15;
                let tooltipY = this.mousePos.y - tooltipHeight / 2;
                
                if (tooltipX + tooltipWidth > this.width) tooltipX = this.mousePos.x - tooltipWidth - 15;
                if (tooltipY < 0) tooltipY = 0;
                if (tooltipY + tooltipHeight > this.height) tooltipY = this.height - tooltipHeight;
                
                // Draw tooltip background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                this.ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                this.ctx.strokeStyle = '#00ff88';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                
                // Draw tooltip text
                this.ctx.fillStyle = '#00ff88';
                this.ctx.font = 'bold 12px "Courier New", monospace';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(node.label, tooltipX + padding, tooltipY + padding + lineHeight);
                
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '11px "Courier New", monospace';
                for (let i = 0; i < lines.length; i++) {
                    this.ctx.fillText(lines[i], tooltipX + padding, tooltipY + padding + (i + 2) * lineHeight);
                }
            }
            
            startAnimation() {
                const animate = () => {
                    this.updatePhysics();
                    this.draw();
                    this.animationId = requestAnimationFrame(animate);
                };
                animate();
            }
            
            stopAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }
            
            updateLayout(layoutType) {
                this.currentLayout = layoutType;
                
                if (layoutType === 'hierarchicalLR') {
                    // Hierarchical left-to-right layout
                    const levels = {
                        'workflow': 0,
                        'core': 1,
                        'build': 2,
                        'deploy': 3,
                        'web': 3,
                        'future': 4
                    };
                    
                    const groupCounts = {};
                    this.nodes.forEach(node => {
                        groupCounts[node.group] = (groupCounts[node.group] || 0) + 1;
                    });
                    
                    const groupIndices = {};
                    this.nodes.forEach(node => {
                        groupIndices[node.group] = (groupIndices[node.group] || 0) + 1;
                        
                        const level = levels[node.group] || 0;
                        const spacing = this.height / (groupCounts[node.group] + 1);
                        
                        node.x = 150 + level * 200;
                        node.y = spacing * groupIndices[node.group];
                        node.vx = 0;
                        node.vy = 0;
                    });
                } else if (layoutType === 'circle') {
                    // Circular layout
                    const centerX = this.width / 2;
                    const centerY = this.height / 2;
                    const radius = Math.min(this.width, this.height) * 0.3;
                    
                    this.nodes.forEach((node, i) => {
                        const angle = (i / this.nodes.length) * 2 * Math.PI;
                        node.x = centerX + Math.cos(angle) * radius;
                        node.y = centerY + Math.sin(angle) * radius;
                        node.vx = 0;
                        node.vy = 0;
                    });
                } else if (layoutType === 'force') {
                    // Reset velocities for force-directed layout
                    this.nodes.forEach(node => {
                        node.vx = (Math.random() - 0.5) * 10;
                        node.vy = (Math.random() - 0.5) * 10;
                    });
                }
            }
            
            togglePhysics() {
                this.physicsEnabled = !this.physicsEnabled;
            }
            
            fitToScreen() {
                // Center all nodes
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                // Calculate current center
                let sumX = 0, sumY = 0;
                this.nodes.forEach(node => {
                    sumX += node.x;
                    sumY += node.y;
                });
                const currentCenterX = sumX / this.nodes.length;
                const currentCenterY = sumY / this.nodes.length;
                
                // Move all nodes to center
                const offsetX = centerX - currentCenterX;
                const offsetY = centerY - currentCenterY;
                
                this.nodes.forEach(node => {
                    node.x += offsetX;
                    node.y += offsetY;
                });
            }
            
            showNodeInfo(node) {
                const infoDiv = document.getElementById('nodeInfo');
                const titleElement = document.getElementById('nodeTitle');
                const descriptionElement = document.getElementById('nodeDescription');
                
                titleElement.textContent = node.label;
                descriptionElement.textContent = node.description;
                
                infoDiv.style.display = 'block';
            }
            
            hideNodeInfo() {
                document.getElementById('nodeInfo').style.display = 'none';
            }
        }
        
        // Initialize visualization when DOM is ready
        let graph;
        
        document.addEventListener('DOMContentLoaded', function() {
            graph = new GraphVisualization('graph-canvas');
            
            // Start with hierarchical layout after a brief delay
            setTimeout(() => {
                graph.updateLayout('hierarchicalLR');
            }, 1000);
        });
        
        // Global functions for controls
        function updateLayout(layoutType) {
            if (graph) graph.updateLayout(layoutType);
        }
        
        function togglePhysics() {
            if (graph) graph.togglePhysics();
        }
        
        function fitToScreen() {
            if (graph) graph.fitToScreen();
        }
        
        // Create network object for compatibility
        window.network = {
            fit: fitToScreen
        };
    </script>
</body>
</html>